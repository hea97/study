# **핵심키워드**

`리스트`  `요소`  `인덱스`  `for반복문` 

---

**리시트(list)**  
사전적 의미 ‘목록’,  python 리스트의 의미는 여러가지 자료를 저장할 수 있는 자료.

# 리스트 선언하고 요소에 접근

Python 리스트를 생성하는 방법은 다음과 같이 대괄호[] 자료를 쉼표 구분 입력.  
대괄호[] 내부에 넣는 자료를 **요소**라 하고 영어로 **element**라 부름.  

간단한 리스트 생성.  
리스트는 한 가지 or 여러 종류의 자료형 형태로 구성할 수 있다.  
프롬프트에 리스트를 입력하면 리스트 내부의 자료를 모두 출력하는 모습을 볼 수 있다.

```python
>>> [1, 2, 3, 4]
[1, 2, 3, 4]
>>> ["안", "녕", "하", "세", "요"]
["안", "녕", "하", "세", "요"]
>>> [13, 15, 17, "문자열", True, False]
[13, 15, 17, "문자열", True, False]
# 순서대로 숫자만, 문자열만, 여러 자료형 구성 리스트 순이다.
```

리스트 안에 있느 요소를 각각 사용하려면 리스트 이름 바로 뒤 대괄호[] 입력,  
자료 위치를 나타내는 숫자 입력.

```python
list_a = [13, 15, 17, "문자열", True, False]
```

각각의 요소는 다음과 같은 형태로 저장된다.  
일반적으로 현실에서는 숫자를 1부터 세지만, 문자열 때처럼 Python은 0부터 센다.

**`list_a`**

| 13 | 15 | 17 | 문자열 | Ture | False |
| --- | --- | --- | --- | --- | --- |
| [0] | [1] | [2] | [3] | [4] | [5] |

리스트 기호인 대괄호[] 안에 들어간 숫자를 **인덱스(index)**.  

```python
>>> list_a = [13, 15, 17, "문자열", True, False]
>>> list_a[0]
13
>>> list_a[1]
15
>>> list_a[2]
17
>>> list_a[1:3]
[15, 17]
```

`list_a[1:3]`의 [1:3] 문자열 범위 선택 연산자로 1번째 글자부터 3번째 그자를 선택하는 것이 아니라 그 앞, 2번째 글자까지 선택 → [15, 17] 출력

리스트 특정 요소는 변경할 수도 있다.   
”변경”이라는 문자열을 0번째 대입하면 요소를 변경할 수 있다.

```python
>>> list_a = [13, 15, 17, "문자열", True, False]
>>> list_a[0] = "변경"
>>> list_a
['변경', 15, 17, "문자열", True, False]
```

**`list_a`**

| 변경 | 15 | 17 | 문자열 | Ture | False |
| --- | --- | --- | --- | --- | --- |
| [0] | [1] | [2] | [3] | [4] | [5] |

## 1. 대괄호 안 음수를 넣어 뒤에서부터 요소를 선택할 때

```python
>>> list_a = [13, 15, 17, "문자열", True, False]
>>> list_a[-1]
False
>>> list_a[-2]
True
>>> list_a[-3]
'문자열'
```

| 13 | 15 | 17 | 문자열 | Ture | False |
| --- | --- | --- | --- | --- | --- |
| [-6] | [-5] | [-4] | [-3] | [-2] | [-1] |

## 2. 리스트 접근 연산자를 다음과 같이 이중으로 사용할 수 있다.

리스트 `list_a[3]` 지정하면 “문자열” 꺼내고 `list_a[3][0]`을 지정, 3번째에서 가져온 “문자열”에서 다시 0번째 가져와 출력

```python
>>> list_a = [13, 15, 17, "문자열", True, False]
>>> list[3]
'문자열'
>>> list_a[3][0]
'문'
```

## 3. 리스트 안에 리스트를 사용할 수 있다.

`list_a`는 리스트 세 개를 가지는 리스트로 만들어짐.

```python
>>> list_a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
>>> list_a[1]
[4, 5, 6]
>>> list_a[1][1]
5
```

## 리스트 `IndexError` 예외

예외는 리스트의 길이를 넘는 인덱스로 요소에 접근할려고 할 때 발생하는 예외이다.  
요소가 존재하지 않는 위치에서 요소를 꺼내려고 할 때 예외가 발생한다.

```python
>>> list_a = [13, 15, 17]
list_a[3]
```

리스트 [3]번째 요소가 없으므로 아래 `IndexError` 예외가 발생한다.

---

Traceback (most recent call last): 

File “<pyshell#3>”, line 1, in <module>

`Indexerror: list index out of range`

---

# 리스트 연산하기 연결(+), 반복(*), len()

문자열과 리스트는 굉장히 비슷한 자료형, 사용할 수 있는 연산자와 함수도 비슷하다.

### 리스트 연산자

`소스 코드 list01.py`

2행과 3행 list_a와 list_b 리스트 선언

```python
list_a = [1, 2, 3]
list_b = [4, 5, 6]
```

7행과 8행은 선언된 리스트 출력

```python
print("list_a = ", list_a)
# list_a = [1, 2, 3]
print("list_b = ", list_b)
# list_b = [4, 5, 6]
```

13행에서는 **연산자 +**를 사용해 `list_a`와 `list_b` 자료 연결  
14행에선 연산자 *를 사용해 `list_a` 자룔를 3번 반복.

```python
print("list_a + list_b = ", list_a + list_b)
# [1, 2, 3, 4, 5, 6]
print("list_a*3 = ", list_a*3)
# [1, 2, 3, 1, 2, 3, 1, 2, 3]
```

**`len()`**  함수 괄호 내부에 문자열을 넣으면 문자열의 글자 수(=길이)를 세어 주고, 리스트 변수를 넣으면 요소의 개수를 세어준다.  
19행은 list_a에 들어있는 요소 개수 구함.

```python
print("len(list_a) =", len(list_a))
# len(list_a) = 3
```

문자열에 연산자를 적용할 때와 비슷한 결과를 출력.

# 리시트에 요소 추가 `append()`, `insert()`

**`append()` 함수**

---

리스트명.append(요소)

---

**`insert()` 함수**

---

리스트명.insert(위치, 요소)

---

### 리스트에 요소 추가

`소스 코드 list02.py`

2행 실행문 `list_a`  넣을 리스트 자료 선언.    
선언하고 나면 각 자료는 다음고 같은 형태로 저장.

```python
list_a = [1, 2, 3]
```

| 1 | 2 | 3 |
| --- | --- | --- |
| [0] | [1] | [2] |

`append()` 함수는 현재 리스트 뒤쪽에 요소를 추가하는 것이므로,  
6행 실행되면 list_a에 4가 추가,  
7행 실행되면 5가 추가,  
→ `list_a = [1, 2, 3, 4, 5]` 

```python
list_a.append(4)
list_a.append(5)
```

| 1 | 2 | 3 | 4 | 5 |
| --- | --- | --- | --- | --- |
| [0] | [1] | [2] | [3] | [4] |

13행의 `insert()` 함수는 괄호 안 정해 준 위치에 요소를 삽입.  
→ 해당 위치 요소는 뒤로 하나씩 밀려 `list_a = [10, 1, 2, 3, 4, 5]`

```python
list_a.insert(0, 10)
# 0 == 삽입할 값
# 10 == 삽입할 값
```

| 10 | 1 | 2 | 3 | 4 | 5 |
| --- | --- | --- | --- | --- | --- |
| [0] | [1] | [2] | [3] | [4] | [5] |

`append()` 함수와 `insert()` 함수는 리스트에 요소 하나를 추가.  
한번에 여러 요소 추가하고 싶을 때 **`extend()`** 함수 사용.  
`extend()` 함수 매개변수로 리스트에 입력.

```python
>>> list_a = [1, 2, 3]
>>> list_a.extend([4, 5, 6])
>>> print(list_a)
[1, 2, 3, 4, 5, 6]
```

`extend()` 함수는 마치 `append()` 함수 세 번 반복 실행한 효과를 가져옴

## 리스트 연결 연산자와 요소 추가의 차이

리스트 연결 연산자와 `extend()` 함수는 비슷한 형태로 동작.  
리스트와 리스트를 연결 기능은 동일. but. 큰차이점 존재.

```python
>>> list_a = [1, 2, 3]
>>> list_b = [4, 5, 6]
>>> list_a + list_b
[1, 2, 3, 4, 5, 6]
>>> list_a
[1, 2, 3]
>>> list_b
[4, 5, 6]
```

리스트 연결 연산자는 연산 결과로 [1, 2, 3, 4, 5, 6]을 출력, 원본에 어떠한 변화도 없다는 것을 확인

`extend()` 함수

```python
>>> list_a = [1, 2, 3]
>>> list_b = [4, 5, 6]
>>> list_a.extend(list_b)
>>> list_a
[1, 2, 3, 4, 5, 6]
>>> list_b
[4, 5, 6]
```

리스트 연결 연산자(`list_a` + `list_b`)만으로 `list_a` 어떠한 영향 주지 않음.  
`extend()` 함수를 사용, `lsit_a` 직접 영향을 준다.

리스트 연결 연산자와 같이 원본에 어떠한 영향도 주지 않는 것을 **비파괴적**이라 표현.
`append()`, `insert()`, `extend()`  함수와 같이 리스트에 직접적인 영향을 주는 함수 또는 연산을 **파괴적**이라 표현.

원 자료는 비파괴적으로 사용이 편리, 비파괴적으로 사용하면 원본도 활용, 새로운 결과도 활용할 수 있으므로 선택직 더 넓기 때문. → 기본 자료형(숫자, 문자열, 불)과 관련 모든 것들은 비파괴적 작동.

but.  리스트는 용량이 매우 커질 수 있다. 프로그래밍 언어 입장에선 용량이 얼마나 큰지도 모르는 것을 ‘원본과 결과’라는 두 가지 생성하는 것은 위험할 수 있다.  
→ Python 프로그래밍 언어는 원본을 직접적으로 조작하는 기능을 제공해서 이러한 위험을 피하는 것이다.

# 리스트에 요소 제거

- 인덱스로 제거하기
- 값으로 제거하기

## 인덱스로 제거하기 del 키워드, `pop()`

요소의 위치를 기반으로 요소를 제거하는 것이다.  
**del 키워드** 또는 **`pop()`** 함수를 사용  
del 키워드는 구문을 사용하며 리스트의 특정 인덱스에 있는 요소 제거.

---

del 리스트명[인덱스]

---

`pop()` 함수 또한 제거할 위치에 있는 요소를 제거, 매개변수를 입력하지 않으면 -1 들어가는 것을 취급해서 마지막 요소를 제거

---

리스트명.pop(인덱스)

---

### 리스트 요소 하나 제거하기

`소스 코드 list03.py`

코드 실행 시 1번째 요소와 2번째 요소가 제거됨.  
제거되는 과정

리스트를 선언하면 `list_a` 에 자료가 

```python
list_a = [0, 1, 2, 3, 4, 5]
```

| 0 | 1 | 2 | 3 | 4 | 5 |
| --- | --- | --- | --- | --- | --- |
| [0] | [1] | [2] | [3] | [4] | [5] |

5행 del 키워드가 가르키는 인덱스가 1번째이므로, 1이 제거 [0, 2, 3, 4 ,5] 출력

```python
del lsit_a[1]
```

| 0 | 1 | 2 | 3 | 4 | 5 |
| --- | --- | --- | --- | --- | --- |
| [0] | [1] | [2] | [3] | [4] | [5] |

9행에서 2번째 요소를 제거 → 3이 제거 되었음.  [0, 2, 4, 5]가 출력  
미세한 동작 차이, 요소를 제거하기 위한 목적으로만 사용되는  경우가 많아 차이를 무시해도 됨.

```python
list_a.pop(2)
```

| 0 | 2 | 4 | 5 |
| --- | --- | --- | --- |
| [0] | [1] | [2] | [3] |

추가로 del 키워드를 사용할 경우,  
범위를 지정해 리스트의 요소를 한꺼번에 제거할 수 있도록 함.  
[3:6] 지정하면 마지막 요소를 포함하지 않는다

```python
>>> list_b = [0, 1, 2, 3, 4, 5, 6]
>>> del list_b[3:6]
>>> list_b
[0, 1, 2, 6]
```

범위 한쪽을 입력하지 않으면 지정한 위치를 기준 한쪽을 전부 제거한다.  
[:3] 지정하면 3을 기준(3번째 불포함)으로 왼쪽을 모두 제거. 

```python
>>> list_c = [0, 1, 2, 3, 4, 5, 6]
>>> del list_c[:3]
>>> list_c
[3, 4, 5, 6]
```

[3:]을 지정함녀 3을 기준(3번째 포함) 오른쪽을 모두 제거.

## 값으로 제거하기 : `remove()`

`remove()`함수 사용

```python
>>> list_c = [1, 2, 1, 2]
>>> list_c.remove(2)
>>> list_c
[1, 1, 2]
```

`remove()` 함수 지정 값이 리스트 내부에 여러 개 있어도 가장 먼저 발견되는 하나만 제거.  
리스트에 2가 두개 있는데 앞쪽에 있는 2 하나만 제거되는 것을 알 수 있다.

만약. 리스트에 중복된 여러 개의 값을 제거하려면 while 반복문과 조합해서 사용해야 한다.

## 모두 제거하기 `clear()`

리스트 내부의 요소를 모두 제거할 때 `clear()` 함수 사용

---

리스트.clear()

---

```python
>>> list_d = [0, 1, 2, 3, 4, 5]
>>> list_d.clear()
>>> list_d
# [] -> 요소가 모두 삭제 되었음
```

# 리스트 정렬 `sort()`

리스트 요소를 정렬하고 싶을 때 `sort()` 함수 사용.  
기본 오름차순 정렬.

---

리스트.sort()

---

```python
>>> list_e = [17, 12, 46, 14, 11, 52, 56]
>>> list_e.sort()
>>> list_e
[11, 12, 14, 17, 46, 52, 56]
>>> list_e.sort(reverse=True) # 내림차순 정렬
>>> list_e
[56, 52, 46, 17, 14 ,12 ,11]
```

# 리스트 내부에 있는지 확인 in/not in 연산자

Python은 리스트 내부에 있는 확인하는 방법을 제공.  
→ **in  연산자**

---

값 in 리스트

---

```python
>>> list_a = [17, 12, 46, 14, 11, 52, 56]
>>> 17 in list_a
True
>>> 14 in list_a
True
>>> 99 in list_a
False
>>> 45 in list_a
False
```

리스트 내부 값이 있으면 `Ture`, 없으면 `False` 출력.  
추가적으로 **not in 연산자** → not in 연산자는 리스트 내부에 해당 값이 없는지 확인하는 연산자, in 연산자와 정확히 반대로 동작.

```python
>>> list_a = [17, 12, 46, 14, 11, 52, 56]
>>> 17 not in list_a
False
>>> 14 not in list_a
False
>>> 99 not in list_a
True
>>> not 45 in list_a
True
```

→ in 연산자를 사용하고 전체를 not으로 감싸는 방법도 사용할 수 있다.  
not in 연산자를 사용하는 것이 훨씬 읽기 쉽다.

# for 반복문

컴퓨터에 반복을 지시하는 방법 == **반복문**

출력 다섯번 하기 (반복문X)

```python
print("출력")
print("출력")
print("출력")
print("출력")
print("출력")
```

무한 반복 작업 싶을 때 코드를 계속 붙여넣기 하는 것은 무리.

```python
for i in range(100)
	print("출력")
```

→ range(100)은 for 반복문과 함께 많이 사용되는 범위 자료형.

# for 반복문 리스트와 함께 사용

for 반복문 기본 형태

---

for 반복문 in 반복할 수 있는 것:

코드

---

반복할 수 있는 것 → 문자열, 리스트, 딕셔너리, 범위.

### for 반복문과 리스트

`소스 코드 for_list.py`

for 반복문은 리시트에 있는 요소 하나하나가 element라는 변수에 들어감, 차례차례 반복함.  
`print()` 함수로 element 출력.

## 중접 리시트와 중첩 반복문

반복문을 여러 겹 중첩해 사용하면 **중첩 반복문.**  
중첩 반복문은 일반적으로 n-차원 처리할 때 사용.

ex. [1, 2, 3] 리스트 한 겹으로 감싸진 리스트를 **1차원 리스트**,  
[[1, 2, 3], [4, 5, 6]]처럼 두 겹 감싸진 리스트를 **2차원 리스트**

→ n-차원 리스트 요소를 모두 확인하려면 반복문을 n번 중첩

```python
list_of_list = [
[1, 2, 3],
[4, 5, 6, 7],
[8, 9]
]
```

`list_of_list` 리스트 안에 리스트가 있는 **중첩 리스트.**  
리스트가 2번 중첩되어 있으므로 2차원 리스트라 한다.

2차원 리스트의 요소를 모두 출력하려면 **for 반복문** 2번 중첩 사용.   
일단 for 반복문을 한 번만 활용할 때, `list_of_list`  요소는 리스트이므로 변수 `items`  리스트가 들어간다. 

실행 시, 리스트를 한 줄에 하나씩 출력하는 것을 확인할 수 있다.

### 2차원 리스트에 반복문 한번 사용

`소스 코드 2dlist01.py`

items를 출력 결과가 리스트이므로 반복문을 한 번더 작용할 수 있다.

### 2차원 리스트에 반복문 두번 사용

`소스 코드 2dlist02.py`

## 전개 연산자

**전개 연산자** 사용하면 리스트 내용을 전개해서 입력할 수 있다.  
리스트 앞에 * 기호를 사용.

---

*리스트 → 리스트[0], 리스트[1], . . .

---

전개 연산자는 기본적으로 1리스트 내부 2함수의 매개변수 위치에 사용.

### 1. 리스트 내부에 사용하는 경우

a 리스트 요소가 1, 2, 3, 4일 때 b 리스트 내부에  *a라 입력하면 1, 2, 3, 4라고 전개해서 입력한 것과 같은 효과를 낸다.  
b = [*a, *a]일 때, b = [1, 2, 3, 4, 1, 2, 3, 4]라는 의미

```python
>>> a = [1, 2, 3, 4]
>>> b = [*a, *a]
>>> b
[1, 2, 3, 4, 1, 2, 3, 4]
```

전개 연산자를 사용하면 `append()` 함수 같이 리스트에 요소 추가 할 때,   
코드를 **비파괴적**으로 구현.

```python
# append() 함수 사용
>>> a = [1, 2, 3, 4]
>>> a.append(5)
>>> a
[1, 2, 3, 4, 5]

# 전개 연산자를 사용한 경우
>>> b = [1, 2, 3, 4]
>>> c = [*b, 5]
>>> b
[1, 2, 3, 4]
>>> c
[1, 2, 3, 4, 5]
```

### 2. 함수 매개변수 위치에 사용하는 경우

리스트 안에 사용하는 것과 마찬가지로 리스트 요소를 하나하나 입력하는 것처럼 전개.

```python
>>> a = [1, 2, 3, 4]
>>> print(*a)
1 2 3 4
```
